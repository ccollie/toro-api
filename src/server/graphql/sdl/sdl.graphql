type Query {
  """Get the list of aggregate types available for metrics"""
  aggregates: [AggregateInfo]!

  """Get general app info"""
  appInfo: AppInfo!

  """Get a queue by id"""
  queue(id: ID!): Queue
  job(queueId: ID!, id: ID!): Job!

  """Validate job data against a schema previously defined on a queue"""
  jobDataValidate(input: JobDataValidateInput!): JobDataValidatePayload!

  """Validate BullMQ job options structure"""
  jobOptionsValidate(input: JobOptionsInput!): ValidateJobOptionsPayload!

  """Find a queue by name"""
  findQueue(hostName: String!, prefix: String, queueName: String!): Queue

  """Get a Host by id"""
  host(id: ID!): QueueHost

  """Get the list of hosts managed by the server instance"""
  hosts: [QueueHost!]!

  """Get a Host by name"""
  hostByName(name: String!): QueueHost

  """Get a queue Metric by id"""
  metric(queueId: ID!, metricId: ID!): Metric
  notificationChannel(hostId: ID!, id: ID!): NotificationChannel

  """Get the list of available metric types"""
  availableMetrics: [MetricInfo!]!

  """Get a queue JobFilter by id"""
  queueJobFilter(input: QueueJobFilterInput): JobFilter

  """Returns the JSON Schema for the BullMq JobOptions type"""
  jobOptionsSchema: JSONSchema!
  rule(queueId: ID!, ruleId: ID!): Rule
  ruleAlert(queueId: ID!, ruleId: ID!, alertId: ID!): RuleAlert

  """Get a JSONSchema document previously set for a job name on a queue"""
  queueJobSchema(input: QueueJobSchemaInput): JobSchema

  """Returns the JSON Schema for the BullMq BulkJobOptions type"""
  bulkJobOptionsSchema: JSONSchema!

  """Infer a JSONSchema from completed jobs in a queue"""
  jobSchemaInfer(input: JobSchemaInferInput): JobSchema
}

type Mutation {
  metricDataRefresh(input: MetricDataRefreshInput!): [MetricDataRefreshPayload]!

  """Create a queue metric"""
  metricCreate(input: MetricCreateInput!): Metric!

  """Update a job metric"""
  metricUpdate(input: MetricInput!): Metric!

  """Delete a queue metric"""
  metricDelete(input: MetricDeleteInput!): MetricDeletePayload!

  """Add a mail notification channel"""
  mailNotificationChannelAdd(input: MailNotificationChannelAddInput!): MailNotificationChannel!

  """Add a slack notification channel"""
  slackNotificationChannelAdd(input: SlackNotificationChannelAddInput!): SlackNotificationChannel!

  """Add a webhook notification channel"""
  webhookNotificationChannelAdd(input: WebhookNotificationChannelAddInput!): WebhookNotificationChannel!
  notificationChannelEnable(hostId: ID!, channelId: ID!): NotificationChannelEnablePayload!
  notificationChannelDisable(hostId: ID!, channelId: ID!): NotificationChannelDisablePayload!
  notificationChannelDelete(hostId: ID!, channelId: ID!): NotificationChannelDeletePayload!
  mailNotificationChannelUpdate(input: MailNotificationChannelUpdateInput!): MailNotificationChannel!
  slackNotificationChannelUpdate(input: SlackNotificationChannelUpdateInput!): SlackNotificationChannel!
  webhookNotificationChannelUpdate(input: WebhookNotificationChannelUpdateInput!): WebhookNotificationChannel!
  jobAdd(input: JobAddInput): Job!
  jobAddBulk(queueId: String!, jobs: [BulkJobItemInput]!): JobAddBulkPayload
  jobAddCron(input: JobAddCronInput!): JobAddCronPayload!
  jobAddEvery(input: JobAddEveryInput): JobAddEveryPayload!
  jobDiscard(input: JobLocatorInput!): JobDiscardPayload!
  jobPromote(input: JobLocatorInput!): JobPromotePayload!
  jobRemove(input: JobLocatorInput!): JobRemovePayload!

  """Bulk deletes a list of jobs by id"""
  jobRemoveBulk(input: BulkJobActionInput!): BulkJobActionPayload
  jobRetry(input: JobLocatorInput!): JobRetryPayload!
  jobUpdate(input: JobUpdateInput!): JobUpdatePayload!
  jobLogAdd(queueId: String!, id: String!, row: String!): JobLogAddPayload!
  jobMoveToCompleted(input: JobLocatorInput!): JobMoveToCompletedPayload!

  """Moves job from active to delayed."""
  jobMoveToDelayed(input: JobMoveToDelayedInput): JobMoveToDelayedPayload!
  jobMoveToFailed(input: JobMoveToFailedInput): JobMoveToFailedPayload!

  """Bulk promotes a list of jobs by id"""
  jobPromoteBulk(input: BulkJobActionInput!): BulkJobActionPayload

  """Bulk retries a list of jobs by id"""
  jobRetryBulk(input: BulkJobActionInput!): BulkJobActionPayload
  repeatableJobRemoveByKey(input: RepeatableJobRemoveByKeyInput!): RepeatableJobRemoveByKeyPayload!
  repeatableJobRemove(id: ID!, jobName: String, repeat: RepeatableJobRemoveOptions!): QueueRemoveRepeatablePayload!

  """
  Remove all jobs created outside of a grace interval in milliseconds. You can clean the jobs with the following states: COMPLETED, wait (typo for WAITING), isActive, DELAYED, and FAILED.
  """
  queueClean(input: QueueCleanFilter!): QueueCleanPayload!

  """
  Drains the queue, i.e., removes all jobs that are waiting or delayed, but not active, completed or failed.
  """
  queueDrain(id: ID!, delayed: Boolean = false): QueueDrainPayload!

  """
  Pause the queue.
  
  A PAUSED queue will not process new jobs until resumed, but current jobs being processed will continue until they are finalized.
  """
  queuePause(id: ID!): Queue!

  """Resume a queue after being PAUSED."""
  queueResume(id: ID!): Queue!
  queueDelete(id: ID!, options: QueueDeleteOptions): QueueDeletePayload!

  """Start tracking a queue"""
  queueRegister(input: RegisterQueueInput): Queue!

  """Stop tracking a queue"""
  queueUnregister(id: ID!): QueueUnregisterPayload!

  """Add a named job filter"""
  queueJobFilterCreate(input: JobFilterInput!): JobFilter!

  """Associate a JSON schema with a job name on a queue"""
  queueJobSchemaSet(input: JobSchemaInput!): JobSchema!

  """Delete a schema associated with a job name on a queue"""
  queueJobSchemaDelete(input: QueueJobSchemaDeleteInput!): QueueJobSchemaDeletePayload!

  """Delete a job filter"""
  queueJobFilterDelete(input: QueueJobFilterDeleteInput!): QueueJobFilterDeletePayload!

  """Update a job filter"""
  queueJobFilterUpdate(input: JobFilterUpdateInput!): JobFilterUpdatePayload!

  """Delete all stats associated with a queue"""
  queueStatsDelete(input: QueueStatsDeleteInput!): QueueStatsDeletePayload!

  """Delete a rule alert"""
  ruleAlertDelete(input: RuleAlertDeleteInput!): RuleAlertDeletePayload!

  """Removes all alerts associated with a rule"""
  ruleAlertsClear(input: RuleAlertsClearInput!): RuleAlertsClearPayload!

  """Delete a rule"""
  ruleDelete(input: RuleDeleteInput!): RuleDeletePayload!

  """Create a rule for a queue"""
  ruleAdd(input: RuleAddInput!): Rule!

  """Removes all alerts associated with a rule"""
  ruleActivate(input: RuleActivateInput!): RuleActivatePayload!

  """Removes all alerts associated with a rule"""
  ruleDeactivate(input: RuleDeactivateInput!): RuleDeactivatePayload!

  """Update a rule"""
  ruleUpdate(input: RuleUpdateInput!): Rule!

  """Delete a rule alert"""
  ruleAlertMarkAsRead(input: RuleAlertMarkAsReadInput!): RuleAlertMarkAsReadPayload!
}

type Subscription {
  onNotificationChannelCreated(
    """The host to monitor"""
    hostId: String!
  ): OnNotificationChannelCreatedPayload!
  onNotificationChannelDeleted(
    """The host to monitor"""
    hostId: String!
  ): OnNotificationChannelDeletedPayload!

  """Subscribe for updates in host statistical snapshots"""
  onHostStatsUpdated(input: StatsUpdatedSubscriptionFilter!): StatsSnapshot!
  onJobAdded(queueId: ID!): OnJobAddedPayload!
  onJobUpdated(queueId: String!, jobId: String!): OnJobUpdatedPayload!
  onJobProgress(queueId: String!, jobId: String!): OnJobProgressPayload!
  onJobRemoved(queueId: String!, jobId: String!): OnJobRemovedPayload!
  onJobLogAdded(queueId: String!, jobId: String!): OnJobLogAddedPayload!

  """Returns job active events"""
  obJobActive(queueId: String!, jobId: String!): OnJobStateChangePayload

  """Returns job failed events"""
  obJobFailed(queueId: String!, jobId: String!): OnJobStateChangePayload

  """Returns job completed events"""
  obJobCompleted(queueId: String!, jobId: String!): OnJobStateChangePayload

  """Returns job stalled events"""
  obJobStalled(queueId: String!, jobId: String!): OnJobStateChangePayload
  onJobDelayed(prefix: String! = "bull", queueId: ID!): OnJobDelayedPayload!
  onQueuePaused(queueId: String!): OnQueuePausedPayload!
  onQueueResumed(queueId: ID!): OnQueueResumedPayload!
  onQueueDeleted(
    """The host to monitor"""
    hostId: String!
  ): OnQueueDeletedPayload!
  onQueueWorkersChanged(queueId: String!): OnQueueWorkersChangedPayload!
  onQueueStateChanged(queueId: String!): OnQueueStateChangedPayload!
  onQueueJobCountsChanged(queueId: String!): OnQueueJobCountsChangedPayload!
  onQueueJobUpdates(input: QueueJobUpdatesFilterInput!): OnQueueJobUpdatesPayload!

  """Subscribe for updates in queue statistical snapshots"""
  onQueueStatsUpdated(input: StatsUpdatedSubscriptionFilter!): StatsSnapshot!
  onQueueRegistered(
    """The host to monitor"""
    hostId: String!
  ): OnQueueRegisteredPayload!
  onQueueUnregistered(
    """The host to monitor"""
    hostId: String!
  ): OnQueueUnregisteredPayload!

  """Returns an updated count of workers assigned to a queue"""
  onQueueWorkersCountChanged(queueId: String!): OnQueueWorkersCountPayload!
  onQueueMetricValueUpdated(queueId: String!, metricId: String!): OnQueueMetricValueUpdated!
  onRuleAlert(queueId: ID!, ruleIds: [String!]): OnRuleAlertPayload!
}

"""The `Boolean` scalar type represents `true` or `false`."""
scalar Boolean

scalar Date

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""
Specifies a duration in milliseconds - either as an int or a string specification e.g. "2 min", "3 hr"
"""
scalar Duration

"""
A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
"""
scalar EmailAddress @specifiedBy(url: "https://www.w3.org/Protocols/rfc822/")

"""
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
"""
scalar Float

"""
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
"""
scalar ID

"""
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
"""
scalar Int

"""Job process. Either a number (percentage) or user specified data"""
scalar JobProgress

"""
Specifies the number of jobs to keep after an operation (e.g. complete or fail).A bool(true) causes a job to be removed after the action
"""
scalar JobRemoveOption

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""
The `JSONSchema` scalar type represents JSONSchema values as specified by https://json-schema.org/draft/2019-09/json-schema-validation.html.
"""
scalar JSONSchema

"""
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
"""
scalar String

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

enum AggregateTypeEnum {
  None
  Identity
  Ewma
  Latest
  Min
  Max
  Mean
  Sum
  StdDev
  Quantile
  P75
  P90
  P95
  P99
  P995
}

enum ChangeAggregation {
  MAX
  MIN
  AVG
  SUM
  P90
  P95
  P99
}

enum ConditionChangeType {
  CHANGE
  PCT
}

enum ErrorLevel {
  NONE
  WARNING
  CRITICAL
}

"""
The method used to calculate the optimal bin width (and consequently number of bins) for a histogram
"""
enum HistogramBinningMethod {
  """
  Maximum of the ‘Sturges’ and ‘Freedman’ estimators. Provides good all around performance.
  """
  Auto

  """Calculate the number of bins based on the Sturges method"""
  Sturges

  """
  Calculate the number of histogram bins based on Freedman-Diaconis method
  """
  Freedman
}

enum HttpMethodEnum {
  GET
  POST
}

enum JobStatus {
  COMPLETED
  WAITING
  ACTIVE
  DELAYED
  FAILED
  PAUSED
  WAITING_CHILDREN
  UNKNOWN
}

enum MetricCategory {
  Queue
  Host
  Redis
}

enum MetricType {
  None
  Apdex
  ActiveJobs
  ConnectedClients
  ConsecutiveFailures
  Completed
  CompletedRate
  CurrentCompletedCount
  CurrentFailedCount
  DelayedJobs
  ErrorRate
  ErrorPercentage
  Failures
  Finished
  FragmentationRatio
  InstantaneousOps
  JobRate
  Latency
  PeakMemory
  PendingCount
  UsedMemory
  Waiting
  WaitingChildren
  WaitTime
}

enum MetricValueType {
  Count
  Gauge
  Rate
}

"""Method used for outlier detection"""
enum OutlierDetectionMethod {
  """Detect outliers based on deviations from the mean."""
  Sigma

  """Detect outliers based on the Inter Quartile Range."""
  IQR

  """
  Detect outliers based on Iglewicz and Hoaglin's method (Mean Absolute Deviation).
  """
  MAD
}

enum PeakSignalDirection {
  ABOVE
  BELOW
  BOTH
}

enum QueueFilterStatus {
  Active
  Inactive
  Paused
  Running
}

enum RuleCircuitState {
  CLOSED
  OPEN
  HALF_OPEN
}

enum RuleOperator {
  EQ
  NE
  GT
  LT
  GTE
  LTE
}

enum RuleState {
  NORMAL
  WARNING
  ERROR
  MUTED
}

enum RuleType {
  THRESHOLD
  PEAK
  CHANGE
}

enum Severity {
  INFO
  WARNING
  ERROR
  CRITICAL
}

enum SortOrderEnum {
  ASC
  DESC
}

enum StatsGranularity {
  Minute
  Hour
  Day
  Week
  Month
}

enum StatsMetricType {
  Latency
  Wait
}

"""Base implementation for job stats information."""
interface JobStatsInterface {
  """The sample size"""
  count: Int!

  """The number of failed jobs in the sample interval"""
  failed: Int!

  """The number of completed jobs in the sample interval"""
  completed: Int!

  """The start of the interval"""
  startTime: Date!

  """The end of the interval"""
  endTime: Date!
}

"""
NotificationChannels provide a consistent ways for users to be notified about incidents.
"""
interface NotificationChannel {
  id: ID!

  """The type of the channel, e.g. slack, email, webhook etc"""
  type: String!

  """The name of the channel"""
  name: String!

  """Is the channel enabled ?"""
  enabled: Boolean!

  """Timestamp of channel creation"""
  createdAt: Date

  """Timestamp of last channel update"""
  updatedAt: Date
}

"""Describes a queue condition were monitoring."""
interface RuleConditionInterface {
  """The value needed to trigger an error notification"""
  errorThreshold: Float!

  """The value needed to trigger an warning notification"""
  warningThreshold: Float

  """The comparison operator"""
  operator: RuleOperator!
}

"""A data point representing the value of a metric in a time series."""
interface TimeseriesDataPointInterface {
  """The timestamp of when the event occurred"""
  ts: Timestamp!

  """The value at the given timestamp"""
  value: Float!
}

type AggregateInfo {
  type: AggregateTypeEnum!
  description: String!
  isWindowed: Boolean!
}

type Aggregator {
  type: AggregateTypeEnum!
  options: JSONObject
}

type AppInfo {
  """The server environment (development, production, etc)"""
  env: String!

  """The app title"""
  title: String!
  brand: String

  """The api version"""
  version: String!
  author: String
}

type BulkJobActionPayload {
  queue: Queue!
  status: [BulkStatusItem]!
}

type BulkStatusItem {
  id: ID!
  success: Boolean!
  reason: String
}

type DiscoverQueuesPayload {
  """The queue name"""
  name: String!

  """The queue prefix"""
  prefix: String!
}

type HistogramBin {
  count: Int!

  """Lower bound of the bin"""
  x0: Float!

  """Upper bound of the bin"""
  x1: Float!
}

"""Records histogram binning data"""
type HistogramPayload {
  """The total number of values."""
  total: Int!

  """The minimum value in the data range."""
  min: Float!

  """The maximum value in the data range."""
  max: Float!

  """The width of the bins"""
  width: Float!
  bins: [HistogramBin]!
}

type Job {
  id: ID!
  name: String!
  data: JSONObject!
  progress: JobProgress
  delay: Int!
  timestamp: Date!
  attemptsMade: Int!
  failedReason: JSON
  stacktrace: [String!]!
  returnvalue: JSON
  finishedOn: Date
  processedOn: Date
  opts: JobOptions!
  state: JobStatus!
  queueId: String!
  parentKey: String
  logs(start: Int! = 0, end: Int! = -1): JobLogs!

  """Returns true if this job is either a parent or child node in a flow."""
  isInFlow: Boolean!

  """returns true if this job is waiting."""
  isWaiting: Boolean!

  """returns true if this job is waiting for children."""
  isWaitingChildren: Boolean!

  """
  Get this jobs children result values as an object indexed by job key, if any.
  """
  childrenValues: JSONObject!

  """Returns the parent of a job that is part of a flow"""
  parent: Job

  """Get children job keys if this job is a parent and has children."""
  dependencies(input: JobDependenciesOptsInput): JobDependenciesPayload!

  """Get children job counts if this job is a parent and has children."""
  dependenciesCount(input: JobDependenciesCountInput): JobDependenciesCountPayload!
}

type JobAddBulkPayload {
  jobs: [Job]!
}

type JobAddCronPayload {
  job: Job
}

type JobAddEveryPayload {
  job: Job!
}

"""The count of jobs according to status"""
type JobCounts {
  completed: Int
  failed: Int
  delayed: Int
  active: Int
  waiting: Int
  paused: Int
}

type JobDataValidatePayload {
  queueId: ID!
  jobName: String!
}

type JobDependenciesCountPayload {
  processed: Int
  unprocessed: Int
}

type JobDependenciesPayload {
  processed: JSONObject
  unprocessed: [String!]
  nextProcessedCursor: Int
  nextUnprocessedCursor: Int
}

"""
Marks a job to not be retried if it fails (even if attempts has been configured)
"""
type JobDiscardPayload {
  job: Job!
}

"""Options for filtering queue jobs"""
type JobFilter {
  id: ID!

  """A descriptive name of the filter"""
  name: String!

  """Optional job status to filter jobs by"""
  status: JobStatus

  """The job filter query"""
  expression: String!

  """The date this filter was created"""
  createdAt: Date
}

type JobFilterUpdatePayload {
  filter: JobFilter
  isUpdated: Boolean!
}

type JobLogAddPayload {
  """The job id"""
  id: String!

  """The number of log entries after adding"""
  count: Int!
  state: JobStatus
}

type JobLogs {
  count: Int!
  items: [String!]!
}

type JobMemoryUsagePayload {
  """The total number of bytes consumed by the sampled jobs"""
  byteCount: Int!

  """The total number of jobs contributing to the byteCount"""
  jobCount: Int!
}

type JobMoveToCompletedPayload {
  queue: Queue!
  job: Job
}

type JobMoveToDelayedPayload {
  job: Job!
  delay: Int!

  """Estimated date/time of execution"""
  executeAt: Date!
}

type JobMoveToFailedPayload {
  job: Job!
  queue: Queue!
}

type JobOptions {
  timestamp: Date

  """
  Ranges from 1 (highest priority) to MAX_INT  (lowest priority). Note that using priorities has a slight impact on performance, so do not use it if not required.
  """
  priority: Int

  """
  An amount of milliseconds to wait until this job can be processed. 
  Note that for accurate delays, worker and producers should have their clocks synchronized.
  """
  delay: Int

  """The total number of attempts to try the job until it completes."""
  attempts: Int

  """Backoff setting for automatic retries if the job fails"""
  backoff: JSON

  """
  if true, adds the job to the right of the queue instead of the left (default false)
  """
  lifo: Boolean

  """
  The number of milliseconds after which the job should be fail with a timeout error [optional]
  """
  timeout: Int

  """
  Override the job ID - by default, the job ID is a unique integer, but you can use this setting to override it. If you use this option, it is up to you to ensure the jobId is unique. If you attempt to add a job with an id that already exists, it will not be added.
  """
  jobId: String

  """
  If true, removes the job when it successfully completes.  A number specify the max amount of jobs to keep.  Default behavior is to keep the job in the COMPLETED set.
  """
  removeOnComplete: JobRemoveOption

  """
  If true, removes the job when it fails after all attempts.  A number specify the max amount of jobs to keep.  Default behavior is to keep the job in the FAILED set.
  """
  removeOnFail: JobRemoveOption

  """
  Limits the amount of stack trace lines that will be recorded in the stacktrace.
  """
  stackTraceLimit: Int

  """Job repeat options"""
  repeat: JobRepeatOptions
}

type JobPromotePayload {
  job: Job!
  queue: Queue!
}

type JobRemovePayload {
  queue: Queue!
  job: Job!
}

type JobRepeatOptions {
  tz: String
  endDate: Date
  limit: Int
  count: Int
  prevMillis: Int
  jobId: String
  startDate: Date
  cron: String
  every: String
}

type JobRetryPayload {
  job: Job!
  queue: Queue!
}

"""Options for validating job data"""
type JobSchema {
  jobName: String!

  """The JSON schema associated with the job name"""
  schema: JSONSchema

  """Default options for jobs off this type created through the API"""
  defaultOpts: JSONObject
}

type JobSearchPayload {
  cursor: String
  hasNext: Boolean!
  jobs: [Job!]!
  total: Int!
  current: Int!
}

type JobUpdateDelta {
  id: String!
  delta: JSONObject!
}

type JobUpdatePayload {
  job: Job!
}

"""A channel which sends notifications through email"""
type MailNotificationChannel implements NotificationChannel {
  id: ID!

  """The type of the channel, e.g. slack, email, webhook etc"""
  type: String!

  """The name of the channel"""
  name: String!

  """Is the channel enabled ?"""
  enabled: Boolean!

  """Timestamp of channel creation"""
  createdAt: Date

  """Timestamp of last channel update"""
  updatedAt: Date

  """Emails of notification recipients"""
  recipients: [EmailAddress]!
}

"""
Records the rate of events over an interval using an exponentially moving average
"""
type Meter {
  """The number of samples."""
  count: Int!

  """The average rate since the meter was started."""
  meanRate: Float!

  """The 1 minute average"""
  m1Rate: Float!

  """The 5 minute average"""
  m5Rate: Float!

  """The 15 minute average"""
  m15Rate: Float!
}

"""Metrics are numeric samples of data collected over time"""
type Metric {
  """the id of the metric"""
  id: ID!
  type: MetricType!

  """The id of the queue to which the metric belongs"""
  queueId: ID!

  """The name of the metric"""
  name: String!

  """A description of the metric being measured."""
  description: String

  """The metric sampling interval."""
  sampleInterval: Int

  """Is the metric active (i.e. is data being collected)."""
  isActive: Boolean!

  """The metric options"""
  options: JSONObject!

  """Timestamp of when this metric was created"""
  createdAt: Date!

  """Timestamp of when this metric was created"""
  updatedAt: Date!
  aggregator: Aggregator!
  data(input: MetricDataInput!): [TimeseriesDataPoint]!

  """
  Uses a rolling mean and a rolling deviation (separate) to identify peaks in metric data
  """
  outliers(input: MetricDataOutliersInput!): [TimeseriesDataPoint]!
  histogram(input: MetricsHistogramInput!): HistogramPayload!

  """Compute a percentile distribution."""
  percentileDistribution(input: MetricPercentileDistributionInput!): PercentileDistribution!

  """Returns simple descriptive statistics from a range of metric data"""
  summaryStats(input: MetricDataInput!): SummaryStatistics!

  """
  Returns the timestamps of the first and last data items recorded for the metric
  """
  dateRange: TimeSpan
}

type MetricDataRefreshPayload {
  metricId: String!
  metric: Metric!
  start: Date
  end: Date
}

type MetricDeletePayload {
  queue: Queue!
  isDeleted: Boolean!
}

type MetricInfo {
  key: String!
  description: String
  category: MetricCategory
  type: MetricType!
  valueType: MetricValueType!
  unit: String
  isPolling: Boolean!
}

type NotificationChannelDeletePayload {
  hostId: ID!
  channelId: ID!
  deleted: Boolean!
}

type NotificationChannelDisablePayload {
  updated: Boolean!
}

type NotificationChannelEnablePayload {
  updated: Boolean!
}

type OnJobAddedPayload {
  jobId: String!
  jobName: String!
  queueId: String!
  queueName: String!
}

type OnJobDelayedPayload {
  job: Job
  queue: Queue!
  jobId: String!
  delay: Int
}

type OnJobLogAddedPayload {
  job: Job!
  queueId: String!
  jobId: String!

  """The rows added to the job log"""
  rows: [String!]!

  """The number of log lines after addition"""
  count: Int!
}

type OnJobProgressPayload {
  job: Job!
  queue: Queue!
  progress: JobProgress
}

type OnJobRemovedPayload {
  queue: Queue!
  jobId: String!
}

type OnJobStateChangePayload {
  job: Job!
  queue: Queue!
}

"""Holds the changes to the state of a job"""
type OnJobUpdatedPayload {
  """The event which triggered the update"""
  event: String!
  timestamp: Date!

  """updates in job state since the last event"""
  delta: JSONObject
  job: Job

  """The job's queue"""
  queue: Queue!
}

type OnNotificationChannelCreatedPayload {
  hostId: String!
  channelId: String!
  channelName: String!
  channelType: String!
}

type OnNotificationChannelDeletedPayload {
  hostId: String!
  channelId: String!
  channelName: String!
  channelType: String!
}

type OnQueueDeletedPayload {
  """The id of the deleted queue"""
  queueId: String!

  """The name of the deleted queue"""
  queueName: String!

  """The queue host id"""
  hostId: String!

  """The number of keys deleted"""
  deletedKeys: Int!
}

type OnQueueJobCountsChangedPayload {
  queueId: String!
  delta: QueueJobCountDelta
}

type OnQueueJobUpdatesPayload {
  queueId: String!
  changes: [JobUpdateDelta!]!
}

"""Returns a stream of metric data updates"""
type OnQueueMetricValueUpdated {
  queueId: String!
  value: Float!

  """The timestamp of the time the value was recorded"""
  ts: Date!
}

type OnQueuePausedPayload {
  queueId: String!
}

type OnQueueRegisteredPayload {
  hostId: String!
  queueId: String!
  queueName: String!
  prefix: String!
}

type OnQueueResumedPayload {
  queueId: String!
}

type OnQueueStateChangedPayload {
  queueId: String!
  queueName: String!
  state: String!
}

type OnQueueUnregisteredPayload {
  hostId: String!
  queueName: String!
  queueId: String!
  prefix: String!
}

"""Returns the list of added and removed workers related to a queue"""
type OnQueueWorkersChangedPayload {
  queueId: String!
  added: [QueueWorker!]!
  removed: [QueueWorker!]!
}

type OnQueueWorkersCountPayload {
  queueId: String!
  workersCount: Int!
}

type OnRuleAlertPayload {
  alert: RuleAlert!
}

type PercentileCount {
  count: Int!

  """The percentile value"""
  value: Float!
}

"""Percentile distribution of metric values"""
type PercentileDistribution {
  """The total number of values."""
  totalCount: Int!

  """The minimum value in the data range."""
  min: Float!

  """The maximum value in the data range."""
  max: Float!
  percentiles: [PercentileCount!]!
}

type PingPayload {
  latency: Int!
}

type Queue {
  id: String!
  prefix: String!
  name: String!

  """Compute the histogram of job data."""
  histogram(input: HistogramInput!): HistogramPayload!
  host: String!
  hostId: ID!
  isPaused: Boolean!
  jobCounts: JobCounts!
  jobNames: [String!]!
  jobFilters(ids: [ID!]): [JobFilter!]!

  """
  Get JSONSchema documents and job defaults previously set for a job names on a queue
  """
  jobSchemas(jobNames: [String!]): [JobSchema!]!

  """Incrementally iterate over a list of jobs filtered by query criteria"""
  jobSearch(filter: JobSearchInput!): JobSearchPayload!

  """Fetch jobs based on a previously stored filter"""
  jobsByFilter(filter: JobsByFilterIdInput!): JobSearchPayload!

  """Get the average runtime duration of completed jobs in the queue"""
  jobDurationAvg(
    """Consider only jobs of this type (optional)"""
    jobName: String

    """An optional upper limit of jobs to use in the average"""
    limit: Int = 100
  ): Int!

  """Get the average memory used by jobs in the queue"""
  jobMemoryAvg(input: JobsMemoryAvgInput): Float!

  """Get the average memory used by jobs in the queue"""
  jobMemoryUsage(input: JobsMemoryAvgInput): JobMemoryUsagePayload!

  """Gets the last recorded queue stats snapshot for a metric"""
  lastStatsSnapshot(input: StatsLatestInput): StatsSnapshot
  metrics: [Metric!]!
  metricCount: Int!

  """Returns the number of jobs waiting to be processed."""
  pendingJobCount: Int!

  """Compute a percentile distribution."""
  percentileDistribution(input: PercentileDistributionInput!): PercentileDistribution!
  repeatableJobs(input: RepeatableJobsInput): [RepeatableJob!]!

  """Returns the number of repeatable jobs"""
  repeatableJobCount: Int!

  """Returns the count of rule alerts associated with a Queue"""
  ruleAlertCount: Int!

  """Gets rule alerts associated with the queue"""
  ruleAlerts(input: QueueRuleAlertsInput): [RuleAlert!]!
  jobs(input: QueueJobsInput): [Job!]!
  jobsById(input: QueueJobsByIdInput): [Job!]!
  rules: [Rule!]!

  """Queries for queue stats snapshots within a range"""
  stats(input: StatsQueryInput!): [StatsSnapshot!]!

  """Aggregates queue statistics within a range"""
  statsAggregate(input: StatsQueryInput!): StatsSnapshot

  """Gets the time range of recorded stats for a queue/host"""
  statsDateRange(input: StatsSpanInput!): TimeSpan

  """
  Gets the current job Throughput rates based on an exponential moving average
  """
  throughput(input: StatsRateQueryInput): Meter!

  """
  Gets the current job Errors rates based on an exponential moving average
  """
  errorRate(input: StatsRateQueryInput): Meter!

  """
  Gets the current job ErrorPercentage rates based on an exponential moving average
  """
  errorPercentageRate(input: StatsRateQueryInput): Meter!

  """Returns the number of jobs waiting to be processed."""
  waitingCount: Int!

  """Returns the number of child jobs waiting to be processed."""
  waitingChildrenCount: Int!

  """Get the average time a job spends in the queue before being processed"""
  waitTimeAvg(
    """Consider only jobs of this type (optional)"""
    jobName: String

    """An optional upper limit of jobs to use in the average"""
    limit: Int = 1000
  ): Int!
  workers(limit: Int): [QueueWorker!]!
  workerCount: Int!
}

type QueueCleanPayload {
  """The queue id"""
  id: ID!

  """Returns the number of affected jobs"""
  count: Int!

  """Returns a list of cleared job ids"""
  jobIds: [ID!]
}

type QueueDeletePayload {
  """The id of the deleted queue"""
  queueId: ID!

  """The name of the deleted queue"""
  queueName: String!

  """The queue host"""
  host: QueueHost!

  """The number of keys deleted"""
  deletedKeys: Int!
}

type QueueDrainPayload {
  queue: Queue!
}

type QueueHost {
  id: ID!

  """
  Returns the number of alerts raised across all the queues associated with this host
  """
  alertCount: Int!

  """Notification channels for alerts"""
  channels: [NotificationChannel!]!

  """An optional description of the host"""
  description: String

  """Discover Bull queues on the given host"""
  discoverQueues(
    """Optional prefix filter"""
    prefix: String = "bull*"

    """
    Return only queues that are not registered. If false it returns all queues in the host instance, whether they are tracked or not
    """
    unregisteredOnly: Boolean = true
  ): [DiscoverQueuesPayload!]!

  """
  Gets the current job ErrorPercentage rates for a host based on an exponential moving average
  """
  errorPercentageRate(input: StatsRateQueryInput): Meter!

  """
  Gets the current job Errors rates for a host based on an exponential moving average
  """
  errorRate(input: StatsRateQueryInput): Meter!

  """Compute the histogram of job data."""
  histogram(input: HistogramInput!): HistogramPayload!

  """Get job counts for a host"""
  jobCounts: JobCounts!

  """Gets the last recorded queue stats snapshot for a metric"""
  lastStatsSnapshot(input: StatsLatestInput): StatsSnapshot

  """The name of the host"""
  name: String!

  """Compute a percentile distribution."""
  percentileDistribution(input: PercentileDistributionInput!): PercentileDistribution!
  ping: PingPayload!

  """The queues registered for this host"""
  queues(filter: HostQueuesFilter): [Queue!]!

  """The count of queues registered for this host"""
  queueCount: Int!
  redis: RedisInfo!

  """Queries for queue stats snapshots within a range"""
  stats(input: StatsQueryInput!): [StatsSnapshot!]!

  """Aggregates queue statistics within a range"""
  statsAggregate(input: StatsQueryInput!): StatsSnapshot

  """Gets the time range of recorded stats for a queue/host"""
  statsDateRange(input: StatsSpanInput!): TimeSpan

  """
  Gets the current job Throughput rates for a host based on an exponential moving average
  """
  throughput(input: StatsRateQueryInput): Meter!
  uri: String!

  """
  Returns the number of workers associated with managed queues on this host
  """
  workerCount: Int!
  workers(limit: Int): [QueueWorker!]!
}

type QueueJobCountDelta {
  completed: Int
  failed: Int
  delayed: Int
  active: Int
  waiting: Int!
}

type QueueJobFilterDeletePayload {
  filterId: String!
  queue: Queue!
  isDeleted: Boolean!
}

type QueueJobSchemaDeletePayload {
  jobName: String!
  queue: Queue!
}

type QueueRemoveRepeatablePayload {
  queue: Queue!
}

type QueueStatsDeletePayload {
  isDeleted: Boolean!
  queue: Queue!
}

type QueueUnregisterPayload {
  host: QueueHost!
  queue: Queue!
  isRemoved: Boolean!
}

type QueueWorker {
  id: String

  """address of the client"""
  addr: String!
  name: String

  """total duration of the connection (in seconds)"""
  age: Int!

  """Idle time of the connection (in seconds)"""
  idle: Int!

  """Date/time when the connection started"""
  started: DateTime

  """the current database number"""
  db: Int!
  role: String
  sub: Int!
  multi: Int!
  qbuf: Int!
  qbufFree: Int!
  obl: Int!
  oll: Int!
  omem: Int!
}

type RedisInfo {
  redis_version: String!
  tcp_port: Int!
  uptime_in_seconds: Int!
  uptime_in_days: Int!
  connected_clients: Int!
  blocked_clients: Int!
  total_system_memory: Int!
  used_memory: Int!
  used_memory_peak: Int!
  used_memory_lua: Int!
  used_cpu_sys: Float!
  maxmemory: Int!
  number_of_cached_scripts: Int!
  instantaneous_ops_per_sec: Int!
  mem_fragmentation_ratio: Float
  role: String!
  os: String!
}

type RepeatableJob {
  key: String!
  name: String
  id: String

  """Date when the repeat job should stop repeating (only with cron)."""
  endDate: Date

  """The timezone for the job"""
  tz: String
  cron: String

  """Human readable description of the cron expression"""
  descr: String
  next: Date
}

type RepeatableJobRemoveByKeyPayload {
  key: String!
  queue: Queue
}

type Rule {
  """The rule id"""
  id: ID!

  """The id of the queue to which the rule belongs"""
  queueId: ID!

  """The names of the rule"""
  name: String!

  """A helpful description of the rule"""
  description: String
  severity: Severity

  """Is this rule active or not"""
  isActive: Boolean!

  """Optional data passed on to alerts"""
  payload: JSONObject

  """
  Optional text for message when an alert is raised. Markdown and handlebars supported
  """
  message: String

  """The rule creation timestamp"""
  createdAt: Date!

  """The timestamp of last update"""
  updatedAt: Date!

  """The last time the rule was triggered"""
  lastTriggeredAt: Date

  """The current rule states"""
  state: RuleState
  status: RuleStatus!

  """The metric being monitored"""
  metric: Metric
  condition: RuleConditionInterface!

  """Rule notification channels"""
  channels: [NotificationChannel!]!

  """Options controlling the generation of events"""
  options: RuleAlertOptions
  alerts(input: RuleAlertsInput): [RuleAlert]!

  """The current count of alerts available for this rule"""
  alertCount: Int!

  """The total number of failures"""
  totalFailures: Int!
}

type RuleActivatePayload {
  isActive: Boolean!
  rule: Rule!
}

"""An event recording the occurrence of an rule violation or reset"""
type RuleAlert {
  id: ID!

  """The id of the rule that raised this alert"""
  ruleId: String!
  status: String!

  """Timestamp of when this alert was raised"""
  raisedAt: DateTime!

  """Timestamp of when this alert was reset"""
  resetAt: DateTime

  """The metric value that crossed the threshold."""
  value: Float!

  """State that triggered alert"""
  state: JSONObject

  """The number of failures before this alert was generated"""
  failures: Int!

  """Optional rule specific data. Corresponds to Rule.payload"""
  payload: JSONObject

  """Error level"""
  errorLevel: ErrorLevel

  """A categorization of the severity of the rule type"""
  severity: Severity

  """Has the alert been read or not"""
  isRead: Boolean!
}

type RuleAlertDeletePayload {
  ruleId: ID!
  rule: Rule
  isDeleted: Boolean!
}

type RuleAlertMarkAsReadPayload {
  alert: RuleAlert!
}

"""Options for raising alerts for a Rule"""
type RuleAlertOptions {
  """
  a timeout after startup (in ms) during which no alerts are raised, irrespective of the truthiness of the rule condition.
  """
  warmupWindow: Duration

  """The minimum number of violations before an alert can be raised"""
  failureThreshold: Int

  """
  Optional number of consecutive successful method executions to close then alert. Default 1
  """
  successThreshold: Int

  """
  The max number of alerts to receive per event trigger in case the condition is met.
   In this case the "event" is a single period between the rule VIOLATION and RESET states.
  """
  maxAlertsPerEvent: Int

  """
  How long an triggered rule must be without failures before resetting it to NORMAL. In conjunction with "alertOnReset", this can be used to prevent a possible storm of notifications when a rule condition passes and fails in rapid succession ("flapping")
  """
  recoveryWindow: Duration

  """If specified, the minimum time between alerts for the same incident"""
  notifyInterval: Duration

  """
  Raise an alert after an event trigger when the situation returns to normal
  """
  alertOnReset: Boolean
}

type RuleAlertsClearPayload {
  """The count of deleted alerts"""
  deletedItems: Int!
  rule: Rule!
}

type RuleDeactivatePayload {
  isActive: Boolean!
  rule: Rule!
}

type RuleDeletePayload {
  ruleId: ID!
  queueId: ID!
  isDeleted: Boolean!
}

"""Real time status of a Rule"""
type RuleStatus {
  """Circuit breaker state."""
  circuitState: RuleCircuitState

  """The rule state."""
  state: RuleState

  """The number of failures for the current event (from trigger to close)"""
  failures: Int!

  """The total number of failures in the lifetime of the rule"""
  totalFailures: Int!

  """
  The number of successful rule invocations after an alert has triggered.
  """
  successes: Int!

  """
  The number of alerts raised for the current failure event (between trigger and close)
  """
  alertCount: Int!

  """The last time the rule triggered"""
  lastFailure: Date

  """The last time a notification was sent"""
  lastNotification: Date
}

"""A channel which sends notifications through slack"""
type SlackNotificationChannel implements NotificationChannel {
  id: ID!

  """The type of the channel, e.g. slack, email, webhook etc"""
  type: String!

  """The name of the channel"""
  name: String!

  """Is the channel enabled ?"""
  enabled: Boolean!

  """Timestamp of channel creation"""
  createdAt: Date

  """Timestamp of last channel update"""
  updatedAt: Date

  """The slack webhook to post messages to"""
  webhook: URL!

  """The slack webhook to post messages to"""
  channel: String

  """A valid slack auth token. Not needed if a webhook is specified"""
  token: String
}

"""Queue job stats snapshot."""
type StatsSnapshot implements JobStatsInterface {
  """The sample size"""
  count: Int!

  """The number of failed jobs in the sample interval"""
  failed: Int!

  """The number of completed jobs in the sample interval"""
  completed: Int!

  """The start of the interval"""
  startTime: Date!

  """The end of the interval"""
  endTime: Date!

  """The average of values during the period"""
  mean: Float!

  """The standard deviation of the dataset over the sample period"""
  stddev: Float!

  """The minimum value in the data set"""
  min: Float!

  """The maximum value in the data set"""
  max: Float!

  """The median value of the data set"""
  median: Float!

  """The 25th percentile"""
  p90: Float!

  """The 95th percentile"""
  p95: Float!

  """The 99th percentile"""
  p99: Float!

  """The 99.5th percentile"""
  p995: Float!

  """
  The average rate of events over the entire lifetime of measurement (e.g., the total number of requests handled,divided by the number of seconds the process has been running), it doesn’t offer a sense of recency.
  """
  meanRate: Float!

  """One minute exponentially weighted moving average"""
  m1Rate: Float!

  """Five minute exponentially weighted moving average"""
  m5Rate: Float!

  """Fifteen minute exponentially weighted moving average"""
  m15Rate: Float!
}

"""Basic descriptive statistics"""
type SummaryStatistics {
  """The number of input values included in calculations"""
  count: Int!

  """The minimum value."""
  min: Float

  """The maximum value."""
  max: Float

  """The average value - the sum of all values over the number of values."""
  mean: Float!

  """
  The median is the middle number of a list. This is often a good indicator of "the middle" when there are outliers that skew the mean value.
  """
  median: Float

  """The variance is the sum of squared deviations from the mean."""
  variance: Float!

  """
  The sample variance is the sum of squared deviations from the mean.
  The sample variance is distinguished from the variance by dividing the sum of squared deviations by (n - 1) instead of n. This corrects the bias in estimating a value from a sample set rather than the full population.
  """
  sampleVariance: Float!

  """
  The standard deviation is the square root of the variance. This is also known as the population standard deviation. It is useful for measuring the amount of variation or dispersion in a set of values.
  """
  standardDeviation: Float!

  """The standard deviation is the square root of the sample variance."""
  sampleStandardDeviation: Float!
}

type TimeseriesDataPoint implements TimeseriesDataPointInterface {
  """The timestamp of when the event occurred"""
  ts: Timestamp!

  """The value at the given timestamp"""
  value: Float!
}

type TimeSpan {
  startTime: DateTime!
  endTime: DateTime!
}

type ValidateJobOptionsPayload {
  isValid: Boolean!
  errors: [String!]!
}

"""A channel that posts notifications to a webhook"""
type WebhookNotificationChannel implements NotificationChannel {
  id: ID!

  """The type of the channel, e.g. slack, email, webhook etc"""
  type: String!

  """The name of the channel"""
  name: String!

  """Is the channel enabled ?"""
  enabled: Boolean!

  """Timestamp of channel creation"""
  createdAt: Date

  """Timestamp of last channel update"""
  updatedAt: Date

  """Url to send data to"""
  url: URL!

  """The HTTP method to use"""
  method: HttpMethodEnum

  """Optional request headers"""
  headers: JSONObject

  """
  Milliseconds to wait for the server to end the response before aborting the client. By default, there is no timeout.
  """
  timeout: Duration

  """The number of times to retry the client"""
  retry: Int

  """Defines if redirect responses should be followed automatically."""
  followRedirect: Boolean

  """
  Set this to true to allow sending body for the GET method. This option is only meant to interact with non-compliant servers when you have no other choice.
  """
  allowGetBody: Boolean

  """Optional success http status codes. Defaults to http codes 200 - 206"""
  httpSuccessCodes: [Int!]
}

input AggregatorInput {
  type: AggregateTypeEnum!
  options: JSONObject
}

input BulkJobActionInput {
  queueId: ID!
  jobIds: [ID!]!
}

input BulkJobItemInput {
  name: String!
  data: JSONObject!
  options: JobOptionsInput
}

input ChangeConditionInput {
  """The value needed to trigger an error notification"""
  errorThreshold: Float!

  """The value needed to trigger an warning notification"""
  warningThreshold: Float

  """The comparison operator"""
  operator: RuleOperator!

  """The sliding window for metric measurement"""
  windowSize: Duration!

  """
  Lookback period (ms). How far back are we going to compare eg 1 hour means we're comparing now vs 1 hour ago
  """
  timeShift: Duration!
  changeType: ConditionChangeType!
  aggregationType: ChangeAggregation!
}

"""Options for generating histogram bins"""
input HistogramBinOptionsInput {
  """Generate a "nice" bin count"""
  pretty: Boolean = true

  """Optional number of bins to select."""
  binCount: Int

  """Method used to compute histogram bin count"""
  binMethod: HistogramBinningMethod = Auto

  """Optional minimum value to include in counts"""
  minValue: Float

  """Optional maximum value to include in counts"""
  maxValue: Float
}

"""Records histogram binning data"""
input HistogramInput {
  """An optional job name to filter on"""
  jobName: String

  """The metric requested"""
  metric: StatsMetricType = Latency

  """Stats snapshot granularity"""
  granularity: StatsGranularity!

  """The minimum date to consider"""
  from: Date!

  """The maximum date to consider"""
  to: Date!
  options: HistogramBinOptionsInput
}

input HostQueuesFilter {
  """Regex pattern for queue name matching"""
  search: String

  """Queue prefix"""
  prefix: String

  """Statuses to filter on"""
  statuses: [QueueFilterStatus]

  """Ids of queues to include"""
  include: [String!]

  """Ids of queues to exclude"""
  exclude: [String!]
}

input JobAddCronInput {
  queueId: ID!
  jobName: ID!
  data: JSONObject
  options: JobOptionsInput
}

input JobAddEveryInput {
  queueId: ID!
  jobName: ID!
  data: JSONObject
  options: JobOptionsInput
}

input JobAddInput {
  queueId: ID!
  jobName: String!
  data: JSONObject
  options: JobOptionsInput
}

input JobDataValidateInput {
  queueId: ID!
  jobName: String!
  data: JSONObject
  opts: JobOptionsInput
}

input JobDependenciesCountInput {
  processed: Boolean
  unprocessed: Boolean
}

input JobDependenciesOptsInput {
  processed: JobDependencyCursorInput
  unprocessed: JobDependencyCursorInput
}

input JobDependencyCursorInput {
  cursor: Int
  count: Int
}

input JobFilterInput {
  queueId: ID!
  name: String!
  status: JobStatus
  expression: String!
}

input JobFilterUpdateInput {
  queueId: ID!
  filterId: ID!
  name: String
  status: JobStatus
  expression: String!
}

input JobLocatorInput {
  queueId: ID!
  jobId: ID!
}

input JobMoveToDelayedInput {
  queueId: ID!
  jobId: String!

  """The amount of time to delay execution (in ms)"""
  delay: Duration = 60000
}

input JobMoveToFailedInput {
  queueId: String!
  jobId: String!
  failedReason: String
}

input JobOptionsInput {
  timestamp: Date

  """
  Ranges from 1 (highest priority) to MAX_INT  (lowest priority). Note that using priorities has a slight impact on performance, so do not use it if not required.
  """
  priority: Int

  """
  An amount of milliseconds to wait until this job can be processed. 
  Note that for accurate delays, worker and producers should have their clocks synchronized.
  """
  delay: Int

  """The total number of attempts to try the job until it completes."""
  attempts: Int

  """Backoff setting for automatic retries if the job fails"""
  backoff: JSON

  """
  if true, adds the job to the right of the queue instead of the left (default false)
  """
  lifo: Boolean

  """
  The number of milliseconds after which the job should be fail with a timeout error [optional]
  """
  timeout: Int

  """
  Override the job ID - by default, the job ID is a unique integer, but you can use this setting to override it. If you use this option, it is up to you to ensure the jobId is unique. If you attempt to add a job with an id that already exists, it will not be added.
  """
  jobId: String

  """
  If true, removes the job when it successfully completes.  A number specify the max amount of jobs to keep.  Default behavior is to keep the job in the COMPLETED set.
  """
  removeOnComplete: JobRemoveOption

  """
  If true, removes the job when it fails after all attempts.  A number specify the max amount of jobs to keep.  Default behavior is to keep the job in the FAILED set.
  """
  removeOnFail: JobRemoveOption

  """
  Limits the amount of stack trace lines that will be recorded in the stacktrace.
  """
  stackTraceLimit: Int
  repeat: JobRepeatOptionsCronInput
}

input JobRepeatOptionsCronInput {
  tz: String
  endDate: Date
  limit: Int
  count: Int
  prevMillis: Int
  jobId: String
  startDate: Date
  cron: String!
}

input JobsByFilterIdInput {
  """The id of the filter"""
  filterId: ID!

  """
  The iterator cursor. Iteration starts when the cursor is set to 0, and terminates when the cursor returned by the server is 0
  """
  cursor: Int = 0

  """The maximum number of jobs to return per iteration"""
  count: Int!
}

input JobSchemaInferInput {
  queueId: ID!
  jobName: String
}

input JobSchemaInput {
  queueId: ID!
  jobName: String!
  schema: JSONSchema!
  defaultOpts: JobOptionsInput
}

input JobSearchInput {
  """Search for jobs having this status"""
  status: JobStatus = COMPLETED

  """The job filter expression"""
  criteria: String

  """
  The iterator cursor. Iteration starts when the cursor is set to null, and terminates when the cursor returned by the server is null
  """
  cursor: String = null

  """The maximum number of jobs to return per iteration"""
  count: Int! = 10
}

input JobsMemoryAvgInput {
  """Job status to consider. Defaults to COMPLETED"""
  status: JobStatus

  """Consider only jobs of this type (optional)"""
  jobName: String

  """An optional upper limit of jobs to sample for the average"""
  limit: Int = 50
}

input JobUpdateInput {
  queueId: String!
  jobId: String!
  data: JSONObject!
}

input MailNotificationChannelAddInput {
  hostId: ID!
  channel: MailNotificationChannelUpdate!
}

input MailNotificationChannelUpdate {
  """The type of the channel, e.g. slack, email, webhook etc"""
  type: String!

  """The name of the channel"""
  name: String!

  """Is the channel enabled ?"""
  enabled: Boolean!

  """Emails of notification recipients"""
  recipients: [EmailAddress]!
}

input MailNotificationChannelUpdateInput {
  hostId: ID!
  channel: MailNotificationChannelUpdate!
}

"""Input fields for creating a metric"""
input MetricCreateInput {
  type: MetricType!

  """The id of the queue to which the metric belongs"""
  queueId: ID!

  """The name of the metric"""
  name: String!

  """A description of the metric being measured."""
  description: String

  """The metric sampling interval."""
  sampleInterval: Int

  """Is the metric active (i.e. is data being collected)."""
  isActive: Boolean!

  """The metric options"""
  options: JSONObject!
  aggregator: AggregatorInput
}

input MetricDataInput {
  start: Date!
  end: Date!
  outlierFilter: OutlierFilterInput
}

input MetricDataOutliersInput {
  start: Date!
  end: Date!
  method: OutlierDetectionMethod! = Sigma

  """
  the threshold for outline detection. Defaults depend on the method of detection
  """
  threshold: Float
}

input MetricDataRefreshInput {
  metricId: String!
  start: Date
  end: Date

  """An expression specifying the range to query e.g. yesterday, last_7days"""
  range: String
}

input MetricDeleteInput {
  queueId: ID!
  metricId: ID!
}

"""Input fields for updating a metric"""
input MetricInput {
  """the id of the metric"""
  id: ID!
  type: MetricType!

  """The id of the queue to which the metric belongs"""
  queueId: ID!

  """The name of the metric"""
  name: String

  """A description of the metric being measured."""
  description: String

  """The metric sampling interval."""
  sampleInterval: Int

  """Is the metric active (i.e. is data being collected)."""
  isActive: Boolean!

  """The metric options"""
  options: JSONObject
  aggregator: AggregatorInput
}

input MetricPercentileDistributionInput {
  from: Date!
  to: Date!
  outlierFilter: OutlierFilterInput

  """The percentiles to get frequencies for"""
  percentiles: [Float!] = [0.5, 0.75, 0.9, 0.95, 0.99, 0.995]
}

"""Compute a frequency distribution of a range of metric data."""
input MetricsHistogramInput {
  """The minimum date to consider"""
  from: Date!

  """The maximum date to consider"""
  to: Date!
  options: HistogramBinOptionsInput
  outlierFilter: OutlierFilterInput
}

"""Input parameters for outlier filtering"""
input OutlierFilterInput {
  method: OutlierDetectionMethod!

  """Optional detection threshold"""
  threshold: Float
}

input PeakConditionInput {
  """Standard deviations at which to trigger an error notification."""
  errorThreshold: Float!

  """Standard deviations at which to trigger an warning notification."""
  warningThreshold: Float

  """The comparison operator"""
  operator: RuleOperator!

  """Signal if peak is above the threshold, below the threshold or either"""
  direction: PeakSignalDirection!

  """
  the influence (between 0 and 1) of new signals on the mean and standard deviation where 1 is normal influence, 0.5 is half
  """
  influence: Float

  """
  The lag of the moving window (in milliseconds).  For example, a lag of 5000 will use the last 5 seconds of observationsto smooth the data.
  """
  lag: Duration
}

"""Records histogram binning data"""
input PercentileDistributionInput {
  """An optional job name to filter on"""
  jobName: String

  """The metric requested"""
  metric: StatsMetricType = Latency

  """Stats snapshot granularity"""
  granularity: StatsGranularity!

  """An expression specifying the range to query e.g. yesterday, last_7days"""
  range: String!

  """The percentiles to get frequencies for"""
  percentiles: [Float!] = [0.5, 0.75, 0.9, 0.95, 0.99, 0.995]
}

input QueueCleanFilter {
  id: ID!

  """Grace period interval (ms). Jobs older this this will be removed."""
  grace: Duration = 0

  """Status of the jobs to clean"""
  status: JobStatus = COMPLETED

  """
  limit Maximum amount of jobs to clean per call. If not provided will clean all matching jobs.
  """
  limit: Int = 0
}

input QueueDeleteOptions {
  checkExistence: Boolean = true
  checkActivity: Boolean = true
}

input QueueJobFilterDeleteInput {
  queueId: ID!
  filterId: ID!
}

input QueueJobFilterInput {
  queueId: ID!
  fieldId: ID!
}

input QueueJobsByIdInput {
  ids: [ID!]!
}

input QueueJobSchemaDeleteInput {
  queueId: ID!
  jobName: String!
}

input QueueJobSchemaInput {
  queueId: ID!
  jobName: String!
}

input QueueJobsInput {
  offset: Int = 0
  limit: Int = 10
  status: JobStatus = COMPLETED
  sortOrder: SortOrderEnum = ASC
}

input QueueJobUpdatesFilterInput {
  queueId: ID!

  """The job names to filter for"""
  names: [String!]

  """Only return updates for jobs with these states"""
  states: [JobStatus]
}

"""Options for retrieving queue rule alerts"""
input QueueRuleAlertsInput {
  """Consider alerts starting on or after this date"""
  startDate: Date

  """Consider alerts ending on or before this date"""
  endDate: Date

  """The sort order of the results. Alerts are sorted by creation date."""
  sortOrder: SortOrderEnum = ASC

  """The maximum number of alerts to return"""
  limit: Int!
}

input QueueStatsDeleteInput {
  queueId: ID!

  """
  Optional job name to delete stats for. If omitted, all queue stats are erased
  """
  jobName: String

  """
  Optional stats granularity. If omitted, the entire range of data is deleted
  """
  granularity: StatsGranularity
}

input RegisterQueueInput {
  hostId: ID!
  prefix: String = "bull"

  """the queue names"""
  name: String!
  checkExists: Boolean = true
  trackMetrics: Boolean = false
}

input RepeatableJobRemoveByKeyInput {
  queueId: ID!
  key: String!
}

input RepeatableJobRemoveOptions {
  tz: String
  endDate: Date
  cron: String
  every: String
}

input RepeatableJobsInput {
  offset: Int = 0
  limit: Int = 20
  order: SortOrderEnum = DESC
}

input RuleActivateInput {
  queueId: ID!
  ruleId: ID!
}

"""Information required to add or edit a Rule"""
input RuleAddInput {
  """The id of the queue to which the rule belongs"""
  queueId: ID!

  """The names of the rule"""
  name: String!

  """A helpful description of the rule"""
  description: String
  severity: Severity

  """Is this rule active or not"""
  isActive: Boolean!

  """Optional data passed on to alerts"""
  payload: JSONObject

  """
  Optional text for message when an alert is raised. Markdown and handlebars supported
  """
  message: String

  """The id of the metric being monitored"""
  metricId: String!

  """The rule condition"""
  condition: RuleConditionInput!

  """Notification channel ids"""
  channels: [String!]

  """Options controlling the generation of events"""
  options: RuleAlertOptionsInput
}

input RuleAlertDeleteInput {
  queueId: ID!
  ruleId: ID!
  alertId: ID!
}

input RuleAlertMarkAsReadInput {
  queueId: ID!
  ruleId: ID!
  alertId: ID!
  isRead: Boolean!
}

input RuleAlertOptionsInput {
  """
  a timeout after startup (in ms) during which no alerts are raised, irrespective of the truthiness of the rule condition.
  """
  warmupWindow: Duration

  """The minimum number of violations before an alert can be raised"""
  failureThreshold: Int

  """
  Optional number of consecutive successful method executions to close then alert. Default 1
  """
  successThreshold: Int

  """
  The max number of alerts to receive per event trigger in case the condition is met.
   In this case the "event" is a single period between the rule VIOLATION and RESET states.
  """
  maxAlertsPerEvent: Int

  """
  How long an triggered rule must be without failures before resetting it to NORMAL. In conjunction with "alertOnReset", this can be used to prevent a possible storm of notifications when a rule condition passes and fails in rapid succession ("flapping")
  """
  recoveryWindow: Duration

  """If specified, the minimum time between alerts for the same incident"""
  notifyInterval: Duration

  """
  Raise an alert after an event trigger when the situation returns to normal
  """
  alertOnReset: Boolean
}

input RuleAlertsClearInput {
  queueId: ID!
  ruleId: ID!
}

input RuleAlertsInput {
  start: Int = 0
  end: Int = 10
  sortOrder: SortOrderEnum = DESC
}

input RuleConditionInput {
  type: RuleType!
  changeCondition: ChangeConditionInput
  peakCondition: PeakConditionInput
  thresholdCondition: ThresholdConditionInput
}

input RuleDeactivateInput {
  queueId: ID!
  ruleId: ID!
}

input RuleDeleteInput {
  queueId: ID!
  ruleId: ID!
}

"""Information needed to update a rule"""
input RuleUpdateInput {
  """The id of the queue to which the rule belongs"""
  queueId: ID!

  """The names of the rule"""
  name: String

  """A helpful description of the rule"""
  description: String
  severity: Severity

  """Is this rule active or not"""
  isActive: Boolean

  """Optional data passed on to alerts"""
  payload: JSONObject

  """
  Optional text for message when an alert is raised. Markdown and handlebars supported
  """
  message: String

  """The id of the metric being monitored"""
  metricId: String

  """The rule condition"""
  condition: RuleConditionInput!

  """Notification channel ids"""
  channels: [String!]

  """Options controlling the generation of events"""
  options: RuleAlertOptionsInput

  """The id of the the rule to update"""
  id: ID!
}

input SlackNotificationChannelAddInput {
  hostId: ID!
  channel: SlackNotificationChannelUpdate!
}

input SlackNotificationChannelUpdate {
  """The type of the channel, e.g. slack, email, webhook etc"""
  type: String!

  """The name of the channel"""
  name: String!

  """Is the channel enabled ?"""
  enabled: Boolean!

  """The slack webhook to post messages to"""
  webhook: URL!

  """The slack webhook to post messages to"""
  channel: String

  """A valid slack auth token. Not needed if a webhook is specified"""
  token: String
}

input SlackNotificationChannelUpdateInput {
  hostId: ID!
  channel: SlackNotificationChannelUpdate!
}

"""Queue stats filter to getting latest snapshot."""
input StatsLatestInput {
  """An optional job name to filter on"""
  jobName: String

  """The metric requested"""
  metric: StatsMetricType = Latency

  """Stats snapshot granularity"""
  granularity: StatsGranularity = Minute
}

"""Queue stats filter."""
input StatsQueryInput {
  """An optional job name to filter on"""
  jobName: String

  """The metric requested"""
  metric: StatsMetricType = Latency

  """Stats snapshot granularity"""
  granularity: StatsGranularity!

  """An expression specifying the range to query e.g. yesterday, last_7days"""
  range: String!
}

"""Queue stats rates filter."""
input StatsRateQueryInput {
  """An optional job name to filter on"""
  jobName: String

  """Stats snapshot granularity"""
  granularity: StatsGranularity!

  """An expression specifying the range to query e.g. yesterday, last_7days"""
  range: String!
}

input StatsSpanInput {
  """The host/queue to query"""
  id: ID!
  jobName: String
  granularity: StatsGranularity
}

"""Filtering options for stats subscriptions."""
input StatsUpdatedSubscriptionFilter {
  """The id of the queue or host to subscribe to"""
  id: ID!

  """An optional job name for filtering"""
  jobName: String

  """The metric requested"""
  metric: StatsMetricType

  """Data granularity"""
  granularity: StatsGranularity
}

input ThresholdConditionInput {
  """The value needed to trigger an error notification"""
  errorThreshold: Float!

  """The value needed to trigger an warning notification"""
  warningThreshold: Float

  """The comparison operator"""
  operator: RuleOperator!
}

input WebhookNotificationChannelAddInput {
  hostId: ID!
  channel: WebhookNotificationChannelUpdate!
}

input WebhookNotificationChannelUpdate {
  """The type of the channel, e.g. slack, email, webhook etc"""
  type: String!

  """The name of the channel"""
  name: String!

  """Is the channel enabled ?"""
  enabled: Boolean!

  """Url to send data to"""
  url: URL!

  """The HTTP method to use"""
  method: HttpMethodEnum = POST

  """Optional request headers"""
  headers: JSONObject

  """
  Milliseconds to wait for the server to end the response before aborting the client. By default, there is no timeout.
  """
  timeout: Duration

  """The number of times to retry the client"""
  retry: Int

  """Defines if redirect responses should be followed automatically."""
  followRedirect: Boolean

  """
  Set this to true to allow sending body for the GET method. This option is only meant to interact with non-compliant servers when you have no other choice.
  """
  allowGetBody: Boolean

  """Optional success http status codes. Defaults to http codes 200 - 206"""
  httpSuccessCodes: [Int!]
}

input WebhookNotificationChannelUpdateInput {
  hostId: ID!
  channel: WebhookNotificationChannelUpdate!
}