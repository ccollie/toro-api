type StatsWindow {
  """the total length of the window"""
  duration: Int
  """the sub-divisions (sampling interval)"""
  period: Int
}

input StatsWindowInput {
  """the total length of the window"""
  duration: Int
  """the sub-divisions (sampling interval)"""
  period: Int
}

enum Granularity {
  MINUTE
  HOUR
  DAY
  WEEK
  MONTH
}

interface StatsInterface {
  count: Int!
  failed: Int
  completed: Int
  startTime: DateTime!
  endTime: DateTime!
  ratePerSecond: Float
}

type Throughput implements StatsInterface {
  count: Int!
  failed: Int
  completed: Int
  startTime: DateTime!
  endTime: DateTime!
  ratePerSecond: Float
}

type StatsSnapshot implements StatsInterface {
  count: Int!
  failed: Int
  completed: Int
  startTime: DateTime!
  endTime: DateTime!
  ratePerSecond: Float
  mean: Float!
  stddev: Float!
  min: Float!
  max: Float!
  p25: Float!
  p50: Float!
  p75: Float!
  p90: Float!
  p95: Float!
  p99: Float!
  p99_5: Float!
}

fragment Counts on StatsSnapshot {
  count
  failed
  completed
}

fragment Percentiles on StatsSnapshot {
  p25
  p50
  p75
  p90
  p95
  p99
  p99_5
}

fragment Throughput on StatsSnapshot {
  count
  failed
  completed
  startTime
  endTime
  ratePerSecond
}

input DateIntervalInput {
  interval: Granularity
  count: Float
}

enum JobTimingType {
  latency
  waitTime
}

input StatsQueryInput {
  queueId: ID!
  jobName: String,
  metric: JobTimingType
  granularity: Granularity
  dateRange: DateRangeInput
}

type StatsSnapshotList {
  count: Int!
  feed(limit: Int = 10, nextCursor: String = null): StatsSnapshot
}

type StatsSnapshotFeed {
  cursor: String
  feed: [StatsSnapshot!]
}

extend type Query {
  latencies(input: StatsQueryInput): StatsSnapshotList
  waitTime(input: StatsQueryInput!): StatsSnapshotList
}
