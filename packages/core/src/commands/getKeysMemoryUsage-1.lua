---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ccollie.
--- DateTime: 6/25/21 7:01 PM
---
--[[
  Gets the memory usage of a collection
  Input:
    KEYS[1]  collection key
    ARGV[1]  keys prefix
    ARGV[2]  limit
    ARGV[3]  optional job name to filter on

  Output:
    (array) [byteCount, jobCount, iterations]
]]
--- try to prevent self DDOS
local MAX_ITERATIONS = 1000
local rcall = redis.call

local key = KEYS[1]
local limit = assert(tonumber(ARGV[2]), 'LIMIT argument must be a number')
local prefix = ARGV[1]
local jobName = ARGV[3] or nil

local isFiltered = jobName ~= nil

local fudge = isFiltered and math.floor(limit / 4) or 0
local delta = limit + fudge
local jobs = {}
local stop = -1
local start = -1 * delta + 1

local t = rcall('TYPE', key)
if type(t) ~= 'string' then
    t = t['ok']
end

local byteCount = 0
local count = 0
local iterations = 0

while (count < limit and iterations < MAX_ITERATIONS) do
    if (t == 'zset') then
        jobs = rcall("ZRANGE", key, start, stop)
    elseif (t == 'list') then
        jobs = rcall("LRANGE", key, start, stop)
    elseif (t == 'set') then
        jobs = rcall("SMEMBERS", key)
    elseif (t == 'hash') then
        jobs = rcall('HKEYS', key)
    end

    if (#jobs > 0) then
        local isValidName
        for _, jobId in ipairs(jobs) do
            iterations = iterations + 1
            local jobKey = prefix .. jobId
            isValidName = true
            if (jobName ~= nil) then
                local name = redis.call('hget', jobKey, 'name')
                isValidName = (name == jobName)
            end
            if (isValidName) then
                byteCount = byteCount + (rcall('memory', 'usage', jobKey) or 0)
                count = count + 1
                if (count == limit) then
                    break
                end
            end
        end

        if (t == 'zset' or t == 'list') then
            stop = start - 1
            start = stop - delta
        else
            break
        end
    else
        break
    end
end

return {byteCount, count, iterations}