---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ccollie.
--- DateTime: 11/1/21 7:15 PM
---

--- @include "isEqual.lua"
--- @include "isNil.lua"
--- @include "some.lua"

local arrayMethods = {}

function arrayMethods.ensureArray(x)
    return type(x) == 'table' and x or { x }
end

--- todo: full copy on each op to ensure immutability
function arrayMethods.push(arr, value)
    if (value == nil) then
        value = cjson.null
    end
    table.insert(arr, value)
    return arr
end

function arrayMethods.pop(arr)
    return table.remove(arr, #arr)
end

function arrayMethods.shift(arr, value)
    return table.remove(arr, 1);
end

function arrayMethods.unshift(arr, value)
    table.insert(arr, 1, value);
    return arr
end

function arrayMethods.reverse(arr)
    local reversed = {}
    local itemCount = #arr
    for k, v in ipairs(arr) do
        reversed[itemCount + 1 - k] = v
    end
    return reversed
end

function arrayMethods.concat(arr, value)
    local type = type(value)
    if (type ~= 'table' and type ~= 'function') then
        return table.insert(arr, value)
    end
    assert(type == 'table', 'Array expected in array.concat()');
    local i = #arr
    for _, v in ipairs(value) do
        i = i + 1
        arr[i] = v
    end
    return arr
end

function arrayMethods.join(arr, glue)
    local res = ''
    local len = #arr
    if glue == nil or glue == cjson.null then
        glue = ','
    else
        glue = tostring(glue)
    end
    for _, v in ipairs(arr) do
        res = res .. tostring(v)
        if _ < len then
            res = res .. glue
        end
    end
    return res
end

function arrayMethods.elementAt(arr, idx)
    -- assert(isArray(arr), 'First operand to $arrayElemAt must resolve to an array');
    idx = assert(tonumber(idx), 'number expected for array index')
    -- translate from 0 to 1 bases
    if idx >= 0 then
        idx = idx + 1
    end
    --- debug('arrayElement. Idx = ' .. toStr(idx))
    local len = #arr
    if (idx < 0 and math.abs(idx) <= len) then
        return arr[idx + len]
    elseif (idx >= 1 and idx <= len) then
        return arr[idx]
    end
    return nil
end

function arrayMethods.indexOf(haystack, needle, start)
    if (isNil(haystack)) then
        return cjson.null
    end
    start = assert(tonumber(start or 0), "indexOf: start index should be a number")

    local len = #haystack
    if (start < 0) then
        start = len + start
    end

    if (len == 0 or start >= len) then
        return -1
    end
    --- convert from 0 to 1 based indices
    start = start + 1

    for i = start, len do
        if (isEqual( haystack[i], needle )) then
            return i - 1
        end
    end
    return -1
end

function arrayMethods.includes(haystack, needle)
    return arrayMethods.indexOf(haystack, needle, 0) >= 0
end

function arrayMethods.slice(arr, startIndex, endIndex)
    assert(isArray(arr), 'slice(): expected string as first argument')
    local length = #arr
    local res = {}
    if (endIndex == nil or endIndex == cjson.null) then
        endIndex = length
    end
    assert(isNumber(endIndex), 'slice(): expected number for endIndex')
    if (endIndex > length) then
        endIndex = length
    end
    if (endIndex < 0) then
        endIndex = length + endIndex
    end
    if (startIndex < 0) then
        startIndex = length + startIndex
    end
    if (startIndex > length) then
        return ''
    end
    -- lua indexes start at 1
    local len = 0
    for i = startIndex + 1, endIndex + 1 do
        len = len + 1
        res[len] = arr[i]
    end
    return res
end

-- @include "intersect.lua"

function arrayMethods.all(a, b)
    if (isArray(a) and isArray(b)) then
        -- order of arguments matter
        local int = intersect(b, a)
        return #b == #int
    end
    return false
end

local function extrema(name, items, comparator)
    local t = type(items)
    if (t == "number") then
        -- take a short cut if expr is number literal
        return items
    end
    if (t == "nil") then
        return nil
    end
    assert(t == "array", name .. ' expects an array of numbers')
    local res = cjson.null
    for _, n in ipairs(items) do
        if (type(n) == 'number') then
            if (res == cjson.null) then
                res = n
            elseif (comparator(n, res)) then
                res = n
            end
        end
    end
    return res
end

function arrayMethods.max(expr)
    return extrema('max', expr, function(x, y) return x > y end)
end

function arrayMethods.min(expr)
    return extrema('min', expr, function(x, y) return x < y end)
end

function arrayMethods.sum(name, args)
    assert(type(args) == 'table', name .. ' expects an array')
    local total = 0
    for _, val in ipairs(args) do
        if type(val) == 'number' then
            total = total + val
        end
    end
    return total
end

function arrayMethods.avg(args)
    local total = arrayMethods.sum('avg', args)
    if total == 0 then
        return 0
    end
    return total / #args
end
