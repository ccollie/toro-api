import { MetricName, MetricType } from '../metric-name';
import { Snapshot } from '../snapshot';

function prometheusTypeName(name: MetricName): string {
  // distributions are reported as derived gauges
  if (name.computedFrom) return prometheusTypeName(name.computedFrom);

  switch (name.type) {
    case MetricType.Counter:
      return 'counter';
    case MetricType.Gauge:
      return 'gauge';
    case MetricType.Distribution:
      return 'summary';
    default:
      return '?';
  }
}

function prometheusName(name: MetricName): string {
  let metricName = name.name;
  let metricTags = name.tags;

  if (name.tags.has('p')) {
    // prometheus has an odd quirk here: percentiles should be marked
    // as "quantile"s, but the sum and count should mangle the original
    // metric name.
    const p = name.tags.get('p') || '';
    metricTags = new Map(name.tags);
    metricTags.delete('p');

    if (p == 'count' || p == 'sum') {
      metricName = `${metricName}_${p}`;
    } else {
      metricTags.set('quantile', p);
    }
  }

  if (metricTags.size == 0) return metricName;

  // prometheus wants OpenTSDB tags to have quoted values.
  const keys = [...metricTags.keys()].sort();
  return (
    metricName +
    '{' +
    keys.map((k) => k + '="' + (metricTags.get(k) || '') + '"').join(',') +
    '}'
  );
}

/*
 * As metrics snapshots are generated, generate a document to serve to
 * Prometheus servers.
 *
 *     const registry = new MetricsRegistry();
 *     registry.events.map(exportPrometheus).subscribe(document => ...);
 *
 * You will need to run a web server to host these. The simplest is:
 *
 *       const router = express.Router();
 *       router.get("/", (request, response) => {
 *         response.set("Content-Type", "text/plain; version=0.0.4");
 *         response.send(lastGeneratedDocument);
 *       });
 *
 * The Prometheus export format is documented here:
 * https://prometheus.io/docs/instrumenting/exposition_formats/
 */
export function exportPrometheus(snapshot: Snapshot): string {
  // we have to do custom flattening here, because prometheus would like
  // the metrics to be sorted by name (so every metric with the same name is
  // grouped together under a single TYPE declaration), and would like to
  // rename some metrics & tags used in distributions.
  const sortedNames = [...snapshot.map.keys()].sort((a, b) => {
    if (a.name != b.name) return a.name.localeCompare(b.name);
    return a.canonical.localeCompare(b.canonical);
  });

  const lines = [
    `# generated by crow ${snapshot.registry.version} @ ${snapshot.timestamp}`,
  ];
  const seenNames = new Set<string>();

  sortedNames.forEach((name) => {
    if (!seenNames.has(name.name)) {
      lines.push(`# TYPE ${name.name} ${prometheusTypeName(name)}`);
      seenNames.add(name.name);
    }
    lines.push(
      `${prometheusName(name)} ${snapshot.map.get(name)} ${snapshot.timestamp}`,
    );
  });

  return lines.join('\n') + '\n';
}
